from __future__ import annotations

"""Simple JSONL log of emotional interactions for language models.

The timestamp is stored in ISO format with UTC timezone.
"""

from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from pathlib import Path
import json
from typing import List, Dict

from .utils import sentiment_score
from . import emotion_analysis


MEMORY_FILE = Path("data/emotional_memory.jsonl")


@dataclass
class EmotionalMemoryNode:
    """A record of a model interaction and resulting emotion."""

    llm_name: str
    prompt: str
    response: str
    emotion: str
    success: bool
    archetype: str
    affect: Dict[str, float] = field(default_factory=dict)
    timestamp: str = field(
        default_factory=lambda: datetime.now(timezone.utc).isoformat()
    )


def record_interaction(node: EmotionalMemoryNode) -> None:
    """Append ``node`` to :data:`MEMORY_FILE` as a JSON line."""
    MEMORY_FILE.parent.mkdir(parents=True, exist_ok=True)
    with MEMORY_FILE.open("a", encoding="utf-8") as fh:
        fh.write(json.dumps(asdict(node), ensure_ascii=False))
        fh.write("\n")


def query_history(llm_name: str) -> List[EmotionalMemoryNode]:
    """Return interaction history for ``llm_name`` from :data:`MEMORY_FILE`."""
    if not MEMORY_FILE.exists():
        return []
    entries: List[EmotionalMemoryNode] = []
    with MEMORY_FILE.open("r", encoding="utf-8") as fh:
        for line in fh:
            try:
                data = json.loads(line)
            except Exception:
                continue
            if data.get("llm_name") != llm_name:
                continue
            try:
                node = EmotionalMemoryNode(**data)
            except Exception:
                # handle missing fields gracefully
                node = EmotionalMemoryNode(
                    llm_name=str(data.get("llm_name", "")),
                    prompt=str(data.get("prompt", "")),
                    response=str(data.get("response", "")),
                    emotion=str(data.get("emotion", "")),
                    success=bool(data.get("success", False)),
                    archetype=str(data.get("archetype", "")),
                    affect=data.get("affect", {}),
                    timestamp=str(data.get("timestamp", "")),
                )
            entries.append(node)
    return entries


def score_affect(response_text: str, user_emotion: str | None = None) -> Dict[str, float]:
    """Return basic resonance metrics for ``response_text``.

    Parameters
    ----------
    response_text:
        The text generated by the model.
    user_emotion:
        Optional emotion label detected for the user. If omitted the last
        value from :func:`INANNA_AI.emotion_analysis.get_emotion_and_tone`
        is used.

    Returns
    -------
    dict[str, float]
        Dictionary containing ``joy``, ``trust`` and ``friction`` scores
        clipped to the ``0..1`` range.
    """

    if user_emotion is None:
        user_emotion, _ = emotion_analysis.get_emotion_and_tone()

    sentiment = sentiment_score(response_text)
    joy = max(0.0, sentiment)
    friction = max(0.0, -sentiment)

    weight = emotion_analysis.emotion_weight(user_emotion)
    trust = max(0.0, min(1.0, weight * (1.0 - friction)))

    return {
        "joy": round(joy, 3),
        "trust": round(trust, 3),
        "friction": round(friction, 3),
    }


__all__ = [
    "EmotionalMemoryNode",
    "record_interaction",
    "query_history",
    "score_affect",
    "MEMORY_FILE",
]
